#pragma once
#ifdef SIMULATION
#include "Arduino_Mock.h"
#else
#include <avr/pgmspace.h>
#endif

#include "../Image.h"

namespace run1_data {
	const uint16_t arcs[] PROGMEM {
		  0x0000
		, 0x0000
		, 0x0000
		, 0x0000
		, 0x0000, 0x782A, 0x7AF9, 0x8BBA, 0x8F10
		, 0x0000, 0x718A, 0x7291, 0x952A, 0x9630
		, 0x0000, 0x6DCA, 0x6EB9, 0x8BFB, 0x8DE1, 0x9ADA, 0x9C48
		, 0x0000, 0x6BD2, 0x6C49, 0x8703, 0x90F9, 0xA31A, 0xA391, 0xA402, 0xA560
		, 0x0000, 0x6A89, 0x8693, 0x9131, 0xABF2, 0xAC59, 0xACCA, 0xAE10
		, 0x0000, 0x6932, 0x6999, 0x86CB, 0x9201, 0xB2CA, 0xB398
		, 0x0000, 0x6861, 0x867B, 0x93C9, 0xB61A, 0xB679, 0xB6DA, 0xB738, 0xBAAA, 0xBC90, 0xBD52, 0xC120
		, 0x0000, 0x67A1, 0x8653, 0x9691, 0xB822, 0xC1E0
		, 0x0000, 0x66CA, 0x6721, 0x85FB, 0x97D1, 0xB75A, 0xC1A0
		, 0x0000, 0x6632, 0x6689, 0x856B, 0x97D1, 0xB70A, 0xC090
		, 0x0000, 0x65A2, 0x65F1, 0x8553, 0x9461, 0xB6E2, 0xC230
		, 0x0000, 0x6551, 0x851B, 0x91A9, 0xB6DA, 0xC288
		, 0x0000, 0x64F1, 0x84C3, 0x9131, 0x9FF3, 0xA491, 0xBA4A, 0xBBB9, 0xBD2A, 0xBE09, 0xBEA2, 0xC218
		, 0x0000, 0x6462, 0x64A9, 0x8493, 0x9109, 0x9F33, 0xA6B1, 0xBE8A, 0xC150
		, 0x0000, 0x6429, 0x8463, 0x90E9, 0x9F0B, 0xA811, 0xBEBA, 0xC050
		, 0x0000, 0x6421, 0x8463, 0x90C1, 0x9F3B, 0xA949, 0xBEB2, 0xBF78
		, 0x0000, 0x63EA, 0x6429, 0x84BB, 0x9121, 0x9FD3, 0xAA81, 0xBE60
		, 0x0000, 0x6432, 0x6469, 0x84CB, 0x91B9, 0xA0D3, 0xAB61, 0xBE88
		, 0x0000, 0x64DA, 0x6551, 0x66BA, 0x6769, 0x70BB, 0x7741, 0x844B, 0x92C1, 0xA1E3, 0xAD11, 0xAD4B, 0xAD89, 0xBE88
		, 0x0000, 0x68B2, 0x68E9, 0x695B, 0x7921, 0x83F3, 0x9581, 0xA1E3, 0xAF61, 0xBEB0
		, 0x0000, 0x6872, 0x6989, 0x69FB, 0x7B31, 0x822B, 0x8929, 0x90CB, 0x9409, 0xA15B, 0xB0D9, 0xB8B2, 0xB8E8, 0xB992, 0xBA39, 0xBEC8
		, 0x0000, 0x67CA, 0x6A21, 0x6A8B, 0x7269, 0x7342, 0x73E0, 0x75CA, 0x7639, 0x76AB, 0x7859, 0x7BF3, 0x8471, 0x8622, 0x8658, 0x93BA, 0x9909, 0x997B, 0x9CD9, 0x9D4B, 0x9D81, 0x9F33, 0xB139, 0xB872, 0xB8A8, 0xBB39, 0xBE98
		, 0x0000, 0x6782, 0x6A99, 0x6B6B, 0x6EB1, 0x70FA, 0x7128, 0x76BA, 0x7721, 0x7792, 0x7C49, 0x7CEB, 0x8139, 0x827A, 0x82A8, 0x94CA, 0x99B8, 0x99EA, 0x9AC1, 0x9E0B, 0x9E41, 0x9E73, 0xA399, 0xA782, 0xA7B1, 0xA822, 0xAA28, 0xAB02, 0xAB31, 0xAC3B, 0xB129, 0xB8C8, 0xBB79, 0xBE22, 0xBE58
		, 0x0000, 0x66BA, 0x6B80, 0x761A, 0x7D19, 0x7F1A, 0x7F80, 0x957A, 0x9978, 0x9F42, 0xA7A8, 0xACDA, 0xAD11, 0xADAB, 0xB141, 0xB942, 0xB970, 0xBAA2, 0xBAD9, 0xBDA0
		, 0x0000, 0x65FA, 0x6A40, 0x752A, 0x7AD0, 0x95EA, 0x9970, 0xA042, 0xA648, 0xAE1A, 0xAE49, 0xAEB3, 0xB1D1, 0xBCBA, 0xBCE8
		, 0x0000, 0x60B2, 0x6908, 0x743A, 0x7898, 0x95FA, 0x9968, 0xA15A, 0xA648, 0xAF31, 0xAF9B, 0xB271, 0xBC48
		, 0x0000, 0x5FEA, 0x67D0, 0x7372, 0x7750, 0x95C2, 0x9940, 0xA27A, 0xA6B8, 0xAFF2, 0xB021, 0xB083, 0xB228, 0xB3D1, 0xBBF0
		, 0x0000, 0x5FFA, 0x6560, 0x731A, 0x76B0, 0x958A, 0x98F8, 0xA3CA, 0xA9C0, 0xB0FA, 0xB129, 0xB1E3, 0xB23A, 0xB268, 0xB491, 0xB4C3, 0xB889, 0xB942, 0xBAE1, 0xBBA0
		, 0x0000, 0x60A2, 0x6150, 0x6182, 0x61D8, 0x7342, 0x76C0, 0x955A, 0x98A8, 0xA52A, 0xAD38, 0xB252, 0xB281, 0xB308, 0xB4F9, 0xB553, 0xB7F1, 0xB822, 0xBB48
		, 0x0000, 0x73C2, 0x77D8, 0x9552, 0x9860, 0xA74A, 0xAD18, 0xB451, 0xB68B, 0xB709, 0xB73B, 0xB761, 0xB7EA, 0xBAF8
		, 0x0000, 0x74C2, 0x78C8, 0x954A, 0x9828, 0xB88A, 0xBA60
		, 0x0000, 0x75B2, 0x78F0, 0x9542, 0x97E0
	}; // 746 bytes

	const uint16_t row_ends[] PROGMEM {		
		0x0000, 0x0001, 0x0002, 0x0003, 0x0008, 0x000D, 0x0014, 0x001D, 
		0x0025, 0x002C, 0x0038, 0x003E, 0x0045, 0x004C, 0x0053, 0x0059, 
		0x0065, 0x006E, 0x0076, 0x007E, 0x0086, 0x008E, 0x009C, 0x00A6, 
		0x00B6, 0x00D1, 0x00F4, 0x0108, 0x0117, 0x0124, 0x0133, 0x0147, 
		0x015A, 0x0168, 0x016F, 0x0174
	}; // 72 bytes

	const uint32_t colors[] PROGMEM {		
		0x00000000, 0x00FFCC00, 0x00FF5555, 0x00FFFFFF
	}; // 16 bytes
}

class run1 : public Image {
protected:
	inline uint16_t get_arc(uint16_t i) override {
		return pgm_read_word(&run1_data::arcs[i]);
	}

	inline uint16_t get_row_end(uint8_t row_index) override {
		return pgm_read_word(&run1_data::row_ends[row_index]);
	}

protected:
	const uint16_t angle_mask = 0xFFF8;
	const uint16_t color_mask = 0x0007;

	inline uint16_t get_angle(uint16_t arc) override {
		return arc & angle_mask;
	}

	inline uint32_t get_color(uint16_t arc) override {
		return pgm_read_dword(&(run1_data::colors[arc & color_mask]));
	}
};
